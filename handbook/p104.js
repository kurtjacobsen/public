// p104.js — pdf.adapter (ESM, rm_b64 per c23c), ASCII-safe
// Goal: comply with proxy contract "POST /pdf/make" expecting { rm_b64: <base64 of ASCII recipe_markdown> }
// API:
//   make(draft:Object, opts?:{ url?:string, timeoutMs?:number, filename?:string })
// Returns: { ok:true, pdfUrl:string, mode:'rm_b64' } | { ok:false, error:string, status?:number, detail?:string }
function toAscii(s){
  return String(s||'').replace(/[^\x00-\x7F]/g, '?');
}

function recipeMarkdown(recipe){
  // Minimal ASCII-safe "recipe_markdown" for PDF
  const lines = [];
  lines.push('# ' + toAscii(recipe.title||'Untitled'));
  lines.push('');
  lines.push('## Ingredients');
  (recipe.ingredients||[]).forEach((it,i)=>{
    const name = toAscii(it.name||('item-'+(i+1)));
    const amt = (it.amount !== undefined ? String(it.amount) : '').trim();
    const unit = toAscii(it.unit||'');
    lines.push('- ' + name + (amt?(' — '+amt+(unit?(' '+unit):'')):''));
  });
  lines.push('');
  lines.push('## Steps');
  (recipe.steps||[]).forEach((st,i)=>{
    lines.push((i+1)+'. ' + toAscii(st));
  });
  lines.push('');
  lines.push('---');
  lines.push('Generated by p104 (rm_b64)');
  return lines.join('\n');
}

export async function make(recipe, opts = {}){
  // validate shape lightly (assumes caller ran q101.validate already)
  if (!recipe || typeof recipe !== 'object' || !recipe.title || !Array.isArray(recipe.ingredients)){
    return { ok:false, error:'PDF_FAIL:BAD_RECIPE' };
  }
  const url = opts.url || (typeof process!=='undefined' && process.env && process.env.PDF_URL);
  if (!url){
    // mock: return about:blank
    const slug = String(recipe.title).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
    return { ok:true, pdfUrl:'about:blank#pdf-'+(slug||'untitled'), mode:'mock' };
  }
  const timeoutMs = typeof opts.timeoutMs === 'number' ? opts.timeoutMs : 12000;
  const filename = opts.filename || 'recipe.txt'; // ASCII filename hint

  const text = recipeMarkdown(recipe);
  const b64 = Buffer.from(text, 'utf8').toString('base64');
  const body = { rm_b64: b64, filename };

  try{
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    const res = await fetch(url, {
      method:'POST',
      headers:{ 'content-type':'application/json', 'accept':'application/json' },
      body: JSON.stringify(body),
      signal: ctrl.signal
    });
    clearTimeout(t);
    const status = res.status;
    const textResp = await res.text();
    if (res.ok){
      let data = null;
      try{ data = textResp ? JSON.parse(textResp) : null; }catch(_){ data = null; }
      const candidate = data || textResp;
      const pdfUrl =
        (candidate && typeof candidate==='object' && (candidate.pdfUrl || candidate.url || candidate.href || candidate.location || candidate.pdf)) ?
          (candidate.pdfUrl || candidate.url || candidate.href || candidate.location || candidate.pdf) :
        (typeof candidate === 'string' && /^https?:\/\//i.test(candidate)) ? candidate : null;
      if (pdfUrl) return { ok:true, pdfUrl, mode:'rm_b64' };
      return { ok:false, error:'PDF_FAIL:NO_URL_IN_OK_RESPONSE' };
    } else {
      let errData = null;
      try{ errData = textResp ? JSON.parse(textResp) : null; }catch(_){}
      const serverMsg = errData && (errData.error || errData.message);
      return { ok:false, error:'HTTP_'+status, status, detail: serverMsg || textResp?.slice(0,200) };
    }
  }catch(e){
    const msg = (e && e.name === 'AbortError') ? 'TIMEOUT' : String(e && e.message || e);
    return { ok:false, error:'PDF_FAIL:'+msg };
  }
}

export default { make };
